<!doctype html>
<meta charset="utf-8">
<title>Mini Battle 3D</title>
<meta name="viewport" content="width=device-width,initial-scale=1">
<style>
Â Â :root{--bg:#0b0d10;--panel:#141a21;--fg:#e8eef3;--muted:#99a2ad;--ok:#48c774;--bad:#ff5d5d}
Â Â html,body{margin:0;height:100%;background:var(--bg);color:var(--fg);font-family:system-ui,-apple-system,Segoe UI,Roboto}
Â Â nav{padding:10px;background:#141a21;border-bottom:1px solid rgba(255,255,255,.08)}
Â Â nav a{color:var(--ok);margin-right:12px;text-decoration:none}
Â Â #wrap{max-width:960px;margin:0 auto;padding:10px}
Â Â canvas{display:block;margin:8px auto;border-radius:14px;box-shadow:0 8px 28px rgba(0,0,0,.35), inset 0 0 0 1px rgba(255,255,255,.06)}
Â Â #hud{position:fixed;left:50%;transform:translateX(-50%);top:10px;display:flex;gap:14px;align-items:center;background:rgba(20,26,33,.75);border:1px solid rgba(255,255,255,.08);padding:8px 12px;border-radius:12px;font-size:14px;backdrop-filter: blur(6px)}
Â Â #hud b{color:var(--fg)}
Â Â #hint{position:fixed;left:50%;top:50%;transform:translate(-50%,-50%);text-align:center;background:rgba(0,0,0,.55);padding:18px 22px;border-radius:14px;border:1px solid rgba(255,255,255,.1);max-width:90%}
Â Â #hint button{margin-top:10px;background:var(--ok);color:#06210f;border:none;border-radius:10px;padding:8px 12px;font-weight:600;cursor:pointer}
Â Â #cross{position:fixed;left:50%;top:50%;transform:translate(-50%,-50%);width:18px;height:18px;opacity:.7}
Â Â #cross:before,#cross:after{content:"";position:absolute;left:50%;top:50%;background:#e8eef3}
Â Â #cross:before{width:2px;height:18px;transform:translate(-50%,-50%)}
Â Â #cross:after{width:18px;height:2px;transform:translate(-50%,-50%)}
Â Â #reload{position:fixed;bottom:14px;left:50%;transform:translateX(-50%);font-size:14px;color:var(--muted)}
Â Â .hpbar{width:120px;height:8px;background:#2a2f37;border-radius:999px;overflow:hidden;border:1px solid rgba(255,255,255,.08)}
Â Â .hp{height:100%;background:linear-gradient(90deg,#ff7b7b,var(--bad));width:100%}
</style>
<nav>
Â Â <a href="/">ğŸ  Home</a>
Â Â <a href="../runner3d/">Runner3D</a>
Â Â <a href="../dash3d/">Dash3D</a>
Â Â <a href="../battle3d/">Mini Battle 3D</a>
</nav>
<div id="wrap"></div>
<div id="hud" aria-live="polite">
Â Â <span>Health:
Â Â Â Â <span class="hpbar"><span id="hp" class="hp"></span></span>
Â Â </span>
Â Â <span>Ammo: <b id="ammo">12</b></span>
Â Â <span>Score: <b id="score">0</b></span>
</div>
<div id="hint">
Â Â <h3 style="margin:0 0 6px 0">Mini Battle 3D</h3>
Â Â <div style="color:var(--muted);font-size:14px">
Â Â Â Â Click to play â€¢ <b>WASD</b> move â€¢ mouse to look â€¢ <b>Space</b> jump â€¢ <b>Click</b> shoot â€¢ <b>R</b> reload.
Â Â Â Â Avoid the red bots and tag them to score!
Â Â </div>
Â Â <button id="playBtn">Click to start</button>
</div>
<div id="cross" aria-hidden="true"></div>
<div id="reload" hidden>Reloadingâ€¦</div>

<script type="module">
import * as THREE from "https://unpkg.com/three@0.160.0/build/three.module.js";
import { PointerLockControls } from "https://unpkg.com/three@0.160.0/examples/jsm/controls/PointerLockControls.js";

const wrap = document.getElementById('wrap');
const scoreEl = document.getElementById('score');
const ammoElÂ Â = document.getElementById('ammo');
const hpElÂ Â Â Â = document.getElementById('hp');
const hintÂ Â Â Â = document.getElementById('hint');
const playBtn = document.getElementById('playBtn');
const reloadUI= document.getElementById('reload');

const scene = new THREE.Scene();
scene.background = new THREE.Color(0x0f1318);
scene.fog = new THREE.Fog(0x0f1318, 35, 140);

const camera = new THREE.PerspectiveCamera(75, 16/9, 0.1, 250);
const renderer = new THREE.WebGLRenderer({antialias:true});
renderer.setPixelRatio(Math.min(devicePixelRatio, 2));
wrap.appendChild(renderer.domElement);

const hemi = new THREE.HemisphereLight(0xffffff, 0x202028, 1.2);
scene.add(hemi);
const dir = new THREE.DirectionalLight(0xffffff, 0.9);
dir.position.set(20,30,-10);
scene.add(dir);

// ground island
const ground = new THREE.Mesh(
Â Â new THREE.CircleGeometry(80, 64),
Â Â new THREE.MeshStandardMaterial({color:0x10161d, roughness:0.95, metalness:0})
);
ground.rotation.x = -Math.PI/2;
ground.receiveShadow = true;
scene.add(ground);

// perimeter posts
const ringMat = new THREE.MeshStandardMaterial({color:0x1a242e, roughness:1});
for(let i=0;i<16;i++){
Â Â const a = (i/16)*Math.PI*2;
Â Â const x = Math.cos(a)*75, z = Math.sin(a)*75;
Â Â const post = new THREE.Mesh(new THREE.CylinderGeometry(0.4,0.4,4,12), ringMat);
Â Â post.position.set(x,2,z);
Â Â scene.add(post);
}

// cover blocks
const colliders = [];
const coverMat = new THREE.MeshStandardMaterial({color:0x182028, roughness:1});
for(let i=0;i<12;i++){
Â Â const b = new THREE.Mesh(new THREE.BoxGeometry(4,3,4), coverMat);
Â Â // scatter within radius 60
Â Â const r = 20 + Math.random()*50, a = Math.random()*Math.PI*2;
Â Â b.position.set(Math.cos(a)*r, 1.5, Math.sin(a)*r);
Â Â scene.add(b); colliders.push(b);
}

// player controls
const controls = new PointerLockControls(camera, renderer.domElement);
scene.add(controls.getObject());
camera.position.set(0, 1.6, 0);
controls.getObject().position.set(0, 1.6, -10);

let moveF=false, moveB=false, moveL=false, moveR=false, canJump=false;
const velocity = new THREE.Vector3();
const direction = new THREE.Vector3();
const upVector = new THREE.Vector3(0,1,0);
const clock = new THREE.Clock();

function onKey(e,down){
Â Â switch(e.code){
Â Â Â Â case 'KeyW': case 'ArrowUp': moveF = down; break;
Â Â Â Â case 'KeyS': case 'ArrowDown': moveB = down; break;
Â Â Â Â case 'KeyA': case 'ArrowLeft': moveL = down; break;
Â Â Â Â case 'KeyD': case 'ArrowRight': moveR = down; break;
Â Â Â Â case 'Space':
Â Â Â Â Â Â if(down && canJump){ velocity.y += 6.5; canJump=false; }
Â Â Â Â Â Â break;
Â Â Â Â case 'KeyR':
Â Â Â Â Â Â if(down) reload();
Â Â Â Â Â Â break;
Â Â }
}
addEventListener('keydown', e=>onKey(e,true));
addEventListener('keyup',Â Â Â e=>onKey(e,false));

// shooting
let ammo = 12, magSize = 12, firing=false, fireCooldown=0;
let reloading=false;

function reload(){
Â Â if(reloading || ammo===magSize) return;
Â Â reloading = true; reloadUI.hidden=false;
Â Â setTimeout(()=>{ ammo = magSize; ammoEl.textContent = ammo; reloading=false; reloadUI.hidden=true; }, 900);
}
addEventListener('mousedown', e=>{
Â Â if(e.button===0) firing = true;
});
addEventListener('mouseup',Â Â Â e=>{
Â Â if(e.button===0) firing = false;
});

function shoot(){
Â Â if(!controls.isLocked || reloading) return;
Â Â if(ammo<=0){ reload(); return; }
Â Â ammo--; ammoEl.textContent = ammo;

Â Â const ray = new THREE.Raycaster();
Â Â ray.setFromCamera(new THREE.Vector2(0,0), camera);
Â Â const targets = enemies.map(e=>e.mesh);
Â Â const hits = ray.intersectObjects(targets, false);
Â Â // muzzle flash line
Â Â const lineGeo = new THREE.BufferGeometry().setFromPoints([camera.position.clone(), camera.getWorldDirection(new THREE.Vector3()).multiplyScalar(50).add(camera.position)]);
Â Â const line = new THREE.Line(lineGeo, new THREE.LineBasicMaterial({color:0xffffff, transparent:true, opacity:0.7}));
Â Â scene.add(line); setTimeout(()=>{ scene.remove(line); line.geometry.dispose(); line.material.dispose(); }, 50);

Â Â if(hits.length){
Â Â Â Â const m = hits[0].object;
Â Â Â Â const enemy = enemies.find(e=>e.mesh===m);
Â Â Â Â if(enemy){
Â Â Â Â Â Â enemy.hp -= 1;
Â Â Â Â Â Â hitEffect(hits[0].point);
Â Â Â Â Â Â if(enemy.hp<=0) { killEnemy(enemy); }
Â Â Â Â }
Â Â }
}

function hitEffect(pos){
Â Â const s = new THREE.Mesh(new THREE.SphereGeometry(0.25,12,12), new THREE.MeshBasicMaterial({color:0xffffff}));
Â Â s.position.copy(pos); scene.add(s);
Â Â setTimeout(()=>{ scene.remove(s); s.geometry.dispose(); s.material.dispose(); }, 120);
}

// enemies
const enemies = [];
function spawnEnemy(){
Â Â const body = new THREE.Mesh(new THREE.BoxGeometry(1.2,1.6,1.2), new THREE.MeshStandardMaterial({color:0xff5d5d}));
Â Â // place away from center (radius 25-60)
Â Â const r = 25 + Math.random()*35, a = Math.random()*Math.PI*2;
Â Â body.position.set(Math.cos(a)*r, 0.8, Math.sin(a)*r);
Â Â scene.add(body);
Â Â enemies.push({mesh:body, hp:3, spd: 2.4 + Math.random()*0.8, dir: new THREE.Vector3()});
}
function killEnemy(e){
Â Â score += 1; scoreEl.textContent = score;
Â Â scene.remove(e.mesh); e.mesh.geometry.dispose(); e.mesh.material.dispose();
Â Â const idx = enemies.indexOf(e); if(idx>-1) enemies.splice(idx,1);
Â Â // respawn after short delay
Â Â setTimeout(spawnEnemy, 600);
}
let score = 0;

// player health
let hp = 100;
function setHP(v){
Â Â hp = Math.max(0, Math.min(100, v));
Â Â hpEl.style.width = hp + '%';
Â Â if(hp<=0) gameOver();
}

// state
let playing = false;
function start(){
Â Â playing = true;
Â Â hint.style.display='none';
Â Â controls.lock();
Â Â // ensure a few enemies exist
Â Â while(enemies.length<5) spawnEnemy();
}
controls.addEventListener('lock', ()=>{ /* locked */ });
controls.addEventListener('unlock', ()=>{ if(playing) hint.style.display=''; });

playBtn.addEventListener('click', start);
renderer.domElement.addEventListener('click', ()=>{ if(!controls.isLocked && playing) controls.lock(); });

// resize
function resize(){
Â Â const w = Math.min(window.innerWidth*0.98, 960);
Â Â const h = w*9/16;
Â Â renderer.setSize(w,h,false);
Â Â camera.aspect = w/h; camera.updateProjectionMatrix();
}
addEventListener('resize', resize); resize();

// simple collision vs island edge (keep within radius)
function clampToIsland(pos){
Â Â const r = Math.hypot(pos.x, pos.z);
Â Â const maxR = 76;
Â Â if(r>maxR){
Â Â Â Â pos.x *= maxR/r;
Â Â Â Â pos.z *= maxR/r;
Â Â }
}

// AABB test utility
const _box = new THREE.Box3(), _p = new THREE.Vector3();
function collideWithCover(nextPos){
Â Â // very simple: if camera head inside a cover AABB, push back along normal
Â Â for(const c of colliders){
Â Â Â Â _box.setFromObject(c);
Â Â Â Â // treat player's body as small box around eyes
Â Â Â Â const playerBox = new THREE.Box3(
Â Â Â Â Â Â new THREE.Vector3(nextPos.x-0.3, nextPos.y-1.6, nextPos.z-0.3),
Â Â Â Â Â Â new THREE.Vector3(nextPos.x+0.3, nextPos.y,Â Â Â Â Â nextPos.z+0.3)
Â Â Â Â );
Â Â Â Â if(playerBox.intersectsBox(_box)){
Â Â Â Â Â Â // push out along the smallest penetration axis
Â Â Â Â Â Â const dx1 = Math.abs(playerBox.max.x - _box.min.x);
Â Â Â Â Â Â const dx2 = Math.abs(_box.max.x - playerBox.min.x);
Â Â Â Â Â Â const dz1 = Math.abs(playerBox.max.z - _box.min.z);
Â Â Â Â Â Â const dz2 = Math.abs(_box.max.z - playerBox.min.z);
Â Â Â Â Â Â const minPen = Math.min(dx1,dx2,dz1,dz2);
Â Â Â Â Â Â if(minPen===dx1) nextPos.x = _box.min.x - 0.31;
Â Â Â Â Â Â else if(minPen===dx2) nextPos.x = _box.max.x + 0.31;
Â Â Â Â Â Â else if(minPen===dz1) nextPos.z = _box.min.z - 0.31;
Â Â Â Â Â Â else nextPos.z = _box.max.z + 0.31;
Â Â Â Â }
Â Â }
}

function updateMovement(delta){
Â Â if(!controls.isLocked) return;

Â Â // friction
Â Â velocity.x -= velocity.x * 8.0 * delta;
Â Â velocity.z -= velocity.z * 8.0 * delta;
Â Â velocity.y -= 20.0 * delta; // gravity

Â Â direction.z = Number(moveF) - Number(moveB);
Â Â direction.x = Number(moveR) - Number(moveL);
Â Â direction.normalize();

Â Â const speed = 24;
Â Â if(moveF || moveB) velocity.z -= direction.z * speed * delta;
Â Â if(moveL || moveR) velocity.x -= direction.x * speed * delta;

Â Â // proposed next position
Â Â const obj = controls.getObject();
Â Â const next = obj.position.clone();

Â Â // forward/back (local)
Â Â const forward = new THREE.Vector3();
Â Â controls.getDirection(forward);
Â Â forward.y = 0; forward.normalize();

Â Â const right = new THREE.Vector3().crossVectors(forward, upVector).negate();

Â Â next.add(forward.multiplyScalar(-velocity.z * delta));
Â Â next.add(right.multiplyScalar(-velocity.x * delta));
Â Â next.y += velocity.y * delta;

Â Â // ground
Â Â if(next.y < 1.6){
Â Â Â Â velocity.y = 0; next.y = 1.6; canJump = true;
Â Â }

Â Â // collisions & bounds
Â Â collideWithCover(next);
Â Â clampToIsland(next);

Â Â obj.position.copy(next);
}

function updateEnemies(delta){
Â Â const playerPos = controls.getObject().position;
Â Â enemies.forEach(e=>{
Â Â Â Â // move toward player
Â Â Â Â const toP = e.mesh.position.clone().sub(playerPos);
Â Â Â Â toP.y = 0; const d = toP.length();
Â Â Â Â if(d>1){
Â Â Â Â Â Â toP.normalize();
Â Â Â Â Â Â // step opposite (toward player)
Â Â Â Â Â Â e.mesh.position.addScaledVector(toP, -e.spd*delta);
Â Â Â Â }
Â Â Â Â // nibble damage if close
Â Â Â Â if(d < 1.6){
Â Â Â Â Â Â setHP(hp - 18*delta); // DPS near enemy
Â Â Â Â }
Â Â });
}

function gameOver(){
Â Â playing = false;
Â Â hint.style.display='';
Â Â hint.querySelector('h3').textContent = "Game Over";
Â Â hint.querySelector('div').innerHTML = "Score: <b>"+score+"</b><br/>Click to play again.";
Â Â // reset state
Â Â enemies.splice(0).forEach(killEnemy);
Â Â score = 0; scoreEl.textContent = 0;
Â Â ammo = magSize; ammoEl.textContent = ammo;
Â Â setHP(100);
}

function animate(){
Â Â const delta = Math.min(0.05, clock.getDelta());
Â Â updateMovement(delta);

Â Â // auto-fire if holding mouse
Â Â fireCooldown -= delta;
Â Â if(firing && fireCooldown<=0){
Â Â Â Â fireCooldown = 0.12; // ~8 shots/sec
Â Â Â Â shoot();
Â Â }

Â Â if(playing) updateEnemies(delta);

Â Â renderer.render(scene, camera);
Â Â requestAnimationFrame(animate);
}
animate();

// initial size
(function init(){
Â Â const w = Math.min(window.innerWidth*0.98, 960);
Â Â const h = w*9/16;
Â Â renderer.setSize(w,h,false);
Â Â camera.aspect = w/h; camera.updateProjectionMatrix();
Â Â ammoEl.textContent = ammo;
Â Â setHP(100);
})();
</script>
