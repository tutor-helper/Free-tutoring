<!doctype html><meta charset="utf-8"><title>Runner3D</title>
<meta name="viewport" content="width=device-width,initial-scale=1">
<style>
Â Â html,body{margin:0;height:100%;background:#0b0d10;color:#e8eef3;font-family:system-ui}
Â Â #wrap{max-width:960px;margin:0 auto;padding:10px}
Â Â #hud{display:flex;gap:14px;justify-content:center;align-items:center;margin:8px auto;color:#99a2ad}
Â Â #hud b{color:#e8eef3}
Â Â #bar{display:flex;gap:12px;justify-content:center;margin:6px 0}
Â Â button{background:#48c774;color:#06210f;border:none;border-radius:10px;padding:8px 12px;font-weight:600;cursor:pointer}
Â Â canvas{display:block;margin:0 auto;border-radius:14px;box-shadow:0 8px 28px rgba(0,0,0,.35),inset 0 0 0 1px rgba(255,255,255,.06)}
Â Â nav{padding:10px;background:#141a21;border-bottom:1px solid rgba(255,255,255,.08)}
Â Â nav a{color:#48c774;margin-right:12px;text-decoration:none}
</style>
<nav>
Â Â <a href="/">ğŸ  Home</a>
Â Â <a href="../runner3d/">Runner3D</a>
Â Â <a href="../dash3d/">Dash3D</a>
Â Â <a href="../blocks3d/">Blocks3D</a>
</nav>
<div id="wrap">
Â Â <div id="hud">Score: <b id="sc">0</b> â€¢ Best: <b id="best">0</b> â€¢ Left/Right to switch lanes â€¢ Space to jump</div>
Â Â <div id="bar"><button id="btn">Start / Pause</button></div>
</div>
<script type="module">
import * as THREE from "https://unpkg.com/three@0.160.0/build/three.module.js";

const wrap = document.getElementById('wrap');
const scoreEl = document.getElementById('sc');
const bestEl = document.getElementById('best'); bestEl.textContent = localStorage.getItem('runner3d_best')||0;
const btn = document.getElementById('btn');

const scene = new THREE.Scene();
scene.background = new THREE.Color(0x0f1318);
const camera = new THREE.PerspectiveCamera(60, 16/9, 0.1, 200);
const renderer = new THREE.WebGLRenderer({antialias:true});
wrap.appendChild(renderer.domElement);

const hemi = new THREE.HemisphereLight(0xffffff, 0x202028, 1.2);
scene.add(hemi);
const dir = new THREE.DirectionalLight(0xffffff, 0.9); dir.position.set(5,8,5); scene.add(dir);

// ground
const ground = new THREE.Mesh(new THREE.PlaneGeometry(30, 180, 1, 1), new THREE.MeshStandardMaterial({color:0x10161d}));
ground.rotation.x = -Math.PI/2; ground.position.z = 50;
scene.add(ground);

// subtle lane lines
const lineMat = new THREE.LineBasicMaterial({color:0xffffff, transparent:true, opacity:0.08});
for (let x of [-6, -0, 6]) {
Â Â const geo = new THREE.BufferGeometry().setFromPoints([new THREE.Vector3(x,0, -10), new THREE.Vector3(x,0,110)]);
Â Â const line = new THREE.Line(geo, lineMat);
Â Â scene.add(line);
}

// player
const ply = new THREE.Mesh(new THREE.BoxGeometry(1.4,1.4,1.4), new THREE.MeshStandardMaterial({color:0x48c774}));
ply.position.set(0,0.7,0); scene.add(ply);

// camera
camera.position.set(0, 5.5, -8);
camera.lookAt(0,1,6);

// resize
function resize(){
Â Â const w = Math.min(window.innerWidth*0.96, 960);
Â Â const h = w * 9/16;
Â Â renderer.setSize(w, h, false);
Â Â renderer.setPixelRatio(Math.min(devicePixelRatio, 2));
Â Â camera.aspect = w/h; camera.updateProjectionMatrix();
}
addEventListener('resize', resize); resize();

// game state
const lanes = [-6, 0, 6];
let laneIdx = 1;
let vy = 0, onGround = true;
let running = false, gameOver = false;
let speed = 0.35;
let score = 0;
const obstacles = [];
const tmpBoxA = new THREE.Box3(), tmpBoxB = new THREE.Box3();

// spawn obstacle
function spawn(){
Â Â const x = lanes[Math.floor(Math.random()*3)];
Â Â const w = 1.6 + Math.random()*0.8, h = 1.2 + Math.random()*1.0, d = 1.6 + Math.random()*0.8;
Â Â const o = new THREE.Mesh(new THREE.BoxGeometry(w,h,d), new THREE.MeshStandardMaterial({color:0xff5d5d}));
Â Â o.position.set(x, h/2, 90 + Math.random()*25);
Â Â scene.add(o); obstacles.push(o);
}
let spawnTimer = 0;

// controls
function startPause(){
Â Â if (gameOver){ reset(); running = true; return; }
Â Â running = !running;
}
btn.addEventListener('click', startPause);

addEventListener('keydown', e=>{
Â Â const k = e.key.toLowerCase();
Â Â if(k===' ') { e.preventDefault(); if(gameOver){ reset(); running=true; } else running = !running; }
Â Â if(!running || gameOver) return;
Â Â if(k==='arrowleft' || k==='a'){ laneIdx = Math.max(0, laneIdx-1); }
Â Â if(k==='arrowright'|| k==='d'){ laneIdx = Math.min(2, laneIdx+1); }
Â Â if(k==='arrowup' || k==='w' || k===' ') { if(onGround){ vy = 0.42; onGround = false; } }
});

// reset
function reset(){
Â Â for(const o of obstacles){ scene.remove(o); o.geometry.dispose(); o.material.dispose(); }
Â Â obstacles.length = 0;
Â Â ply.position.set(0,0.7,0);
Â Â laneIdx = 1; vy = 0; onGround = true; score = 0; speed = 0.35;
Â Â running = false; gameOver = false; scoreEl.textContent = score;
}

// step
function tick(){
Â Â requestAnimationFrame(tick);

Â Â // smooth move to lane
Â Â ply.position.x += (lanes[laneIdx] - ply.position.x) * 0.2;

Â Â // gravity
Â Â if(running){
Â Â Â Â vy -= 0.018; // gravity
Â Â Â Â ply.position.y += vy;
Â Â Â Â if(ply.position.y <= 0.7){ ply.position.y = 0.7; vy = 0; onGround = true; }
Â Â }

Â Â // obstacles
Â Â if(running && !gameOver){
Â Â Â Â spawnTimer--; if(spawnTimer<=0){ spawn(); spawnTimer = 48 + Math.floor(Math.random()*30); }
Â Â Â Â for(const o of obstacles){
Â Â Â Â Â Â o.position.z -= speed*3.2;
Â Â Â Â }
Â Â Â Â // remove + score
Â Â Â Â while(obstacles.length && obstacles[0].position.z < -12){
Â Â Â Â Â Â const gone = obstacles.shift(); scene.remove(gone); gone.geometry.dispose(); gone.material.dispose();
Â Â Â Â Â Â score++; scoreEl.textContent = score;
Â Â Â Â Â Â if(score % 6 === 0) speed = Math.min(0.7, speed + 0.04);
Â Â Â Â }
Â Â Â Â // collision
Â Â Â Â tmpBoxA.setFromObject(ply);
Â Â Â Â for(const o of obstacles){
Â Â Â Â Â Â tmpBoxB.setFromObject(o);
Â Â Â Â Â Â if(tmpBoxA.intersectsBox(tmpBoxB)){
Â Â Â Â Â Â Â Â gameOver = true; running = false;
Â Â Â Â Â Â Â Â const best = Math.max(Number(localStorage.getItem('runner3d_best')||0), score);
Â Â Â Â Â Â Â Â localStorage.setItem('runner3d_best', best); bestEl.textContent = best;
Â Â Â Â Â Â Â Â break;
Â Â Â Â Â Â }
Â Â Â Â }
Â Â }

Â Â // keep ground under camera
Â Â ground.position.z -= speed*3.2 * (running?1:0);
Â Â if(ground.position.z < 0) ground.position.z += 50;

Â Â renderer.render(scene, camera);
}
reset(); tick();
</script>
